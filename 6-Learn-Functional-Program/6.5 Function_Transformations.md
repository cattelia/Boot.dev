![alt text](img/image-3.png)

# <div align="center">Function Transformations</div>

### Work done by <span style="color:#ECAD35">Sara Eilenstine</span>, course and media are through <a href="https://www.boot.dev/">Boot.dev</a>!

<br>

# WHAT'S FUNCTION TRANSFORMATION?

"Function transformation" is just a more concise way to describe a specific type of <a href="https://en.wikipedia.org/wiki/Higher-order_function">higher order function</a>. It's when a function takes a function (or functions) as input and returns a new function. Let's look at an example:

![alt text](img/fxnTransform.png)

```python
def multiply(x, y):
    return x * y

def add(x, y):
    return x + y

# self_math is a higher order function
# input: a function that takes two arguments and returns a value
# output: a new function that takes one argumentÂ and returns a value
def self_math(math_func):
    def inner_func(x):
        return math_func(x, x)
    return inner_func

square_func = self_math(multiply)
double_func = self_math(add)

print(square_func(5))
# prints 25

print(double_func(5))
# prints 10
```

The `self_math` function takes a function that operates on two different parameters (e.g. multiply or add) and returns a new function that operates on one parameter twice (e.g. square or double).

# <span style="color:#0F77A5"><strong>Assignment</strong></span>

Doc2Doc needs a good logging system so that users and developers alike can see what's going on under the hood. Complete the `get_logger` function.

It takes a `formatter` function as a parameter and returns a new function. Steps:

1. Define a new function inside `get_logger` (see `self_math` above as an example). It accepts two strings. You can just name them `first` and `second` if you like.
2. The `logger` function should _not return anything_. It should simply `print` the result of calling the given `formatter` function with the `first` and `second` strings as arguments.
3. Return the new `logger` function for the test suite to use.

### TIP

// _The `colon_delimit` and `dash_delimit` functions are "formatters" that will be passed into our get_logger function by the tests. You don't need to touch them, but it's important to understand that when you `call formatter()` in the `get_logger` function, you're calling one of these functions._

# <span style="color:#ECAD35">Solution</span>

```python
def get_logger(formatter):
    # ?
    def log_format(first, second):
        print(formatter(first, second))

    return log_format


# Don't edit below this line

def test(first, errors, formatter):
    print("Logs:")
    logger = get_logger(formatter)
    for err in errors:
        logger(first, err)
    print("====================================")


def colon_delimit(first, second):
    return f"{first}: {second}"


def dash_delimit(first, second):
    return f"{first} - {second}"


def main():
    db_errors = [
        "out of memory",
        "cpu is pegged",
        "networking issue",
        "invalid syntax",
    ]
    test("Doc2Doc FATAL", db_errors, colon_delimit)

    mail_errors = [
        "email too large",
        "non alphanumeric symbols found",
    ]
    test("Doc2Doc WARNING", mail_errors, dash_delimit)


main()

'''
Output:
Logs:
Doc2Doc FATAL: out of memory
Doc2Doc FATAL: cpu is pegged
Doc2Doc FATAL: networking issue
Doc2Doc FATAL: invalid syntax
====================================
Logs:
Doc2Doc WARNING - email too large
Doc2Doc WARNING - non alphanumeric symbols found
====================================
'''
```

# TRANSFORMATIONS REVIEW

**Example of a function transformation:**

```python
def multiply(x, y):
    return x * y

def add(x, y):
    return x + y

def self_math(math_func):
    # inner_func is defined inside self_math.
    # It can only be referenced directly
    # inside self_math's scope. However, it is then
    # returned and can be captured into a new variable
    # like square_func or double_func, and called that way
    def inner_func(x):
        return math_func(x, x)
    return inner_func

square_func = self_math(multiply)
double_func = self_math(add)

print(square_func(5))
# 25

print(double_func(5))
# 10
```

### Answer these questions:

```python
# What does the expression 'self_math(add)' return?
A function '''return inner_func'''

# Where can 'inner_func' be referenced directly?
Only within self_math()
```

# MORE TRANSFORMATIONS

Here's some example code for you to reference as you work through the assignment:

```python
def multiply(x, y):
    return x * y

def add(x, y):
    return x + y

def self_math(math_func):
    def inner_func(x):
        return math_func(x, x)
    return inner_func

square_func = self_math(multiply)
double_func = self_math(add)

print(square_func(5))
# prints 25

print(double_func(5))
# prints 10
```

# <span style="color:#0F77A5"><strong>Assignment</strong></span>

Complete the `doc_format_checker_and_converter` function.

It takes a `conversion_function` and a list of `valid_formats` as parameters. It should return a _new function_ that takes two parameters of its own:

- `filename`: The name of the file to be converted
- `content`: The content (body text) of the file to be converted

If the file extension of the `filename` is in the `valid_formats` list, then it should return the result of calling the `conversion_function` on the `content`. Otherwise, it should <a href="https://docs.python.org/3/tutorial/errors.html#raising-exceptions">raise</a> a <a href="https://docs.python.org/3/library/exceptions.html#ValueError">ValueError</a> with the message `"Invalid file format"`.

# <span style="color:#ECAD35">Solution</span>

```python
def doc_format_checker_and_converter(conversion_function, valid_formats):

    def doc_checker(filename, content):
        check_filename = filename.split(".")
        if check_filename[1] in valid_formats:
            return conversion_function(content)
        else:
            raise ValueError("Invalid file format")

    return doc_checker


# Don't edit below this line

def capitalize_content(content):
    return content.upper()


def reverse_content(content):
    return content[::-1]
```

### TIP

// _I used the `.split()` method on the `filename` to get the file extension. You can use the `in` keyword to check if a value is in a list._

// _The `capitalize_content` and `reverse_content` are "conversion functions" that will be passed into our `doc_format_checker_and_converter` function by the tests._

# WHY TRANSFORM?

You might be wondering:

- "When would I use function transformations in the real world?"
- "Isn't it simpler to just define functions at the top level of the code, and call them as needed?"

Good questions. To be clear, we don't just transform functions at <a href="https://en.wikipedia.org/wiki/Execution_(computing)#Runtime">runtime</a> for the fun of it! We only use advanced techniques like function transformations when they make our code _simpler than it would otherwise be_.

## CODE REUSABILITY

Creating variations of the same function dynamically can make it a lot easier to share common functionality. Take a look at this `formatter` function. It accepts a "pattern" and returns a new function that formats text according to that pattern:

```python
def formatter(pattern):
    def inner_func(text):
        result = ""
        i = 0
        while i < len(pattern):
            if pattern[i:i+2] == '{}':
                result += text
                i += 2
            else:
                result += pattern[i]
                i += 1
        return result
    return inner_func
```

Now we can create new formatters easily:

```python
bold_formatter = formatter("**{}**")
italic_formatter = formatter("*{}*")
bullet_point_formatter = formatter("* {}")
```

And use them like this:

```python
print(bold_formatter("Hello"))
# **Hello**
print(italic_formatter("Hello"))
# *Hello*
print(bullet_point_formatter("Hello"))
# * Hello
```

## CLOSURES

90% of the time, when I use function transformations, it's because I want to create a closure. We'll talk about closures in the next chapter!

## Answer these questions:

```python
# We should use function transformations ____
When it results in more understandable and extendable code

# Couldn't we just explicitly define bold_formatter, italic_formatter, and bullet_point_formatter as normal functions?
Yes, but it would probably require more code
```

### Work done by <span style="color:#ECAD35">Sara Eilenstine</span>, course and media are through <a href="https://www.boot.dev/">Boot.dev</a>!

<br>

![alt text](img/image-4.png)
